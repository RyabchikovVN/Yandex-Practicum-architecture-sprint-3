
# Задание 1. Анализ и планирование

## 1.  Изучите функциональность монолитного приложения:
    
*   **Управление отоплением.** Пользователи могут удалённо включать/выключать отопление в своих домах.
        
*   **Мониторинг температуры.** Система получает данные о температуре с датчиков, установленных в домах. Пользователи могут просматривать текущую температуру в своих домах через веб-интерфейс.
        
## 2.  Проанализируйте архитектуру монолитного приложения:
    
*   **Язык программирования:** Java
        
*   **База данных:** PostgreSQL
        
*   **Архитектура:** Монолитная, все компоненты системы (обработка запросов, бизнес-логика, работа с данными) находятся в рамках одного приложения.
        
*   **Взаимодействие:** Синхронное, запросы обрабатываются последовательно.
        
*   **Масштабируемость:** Ограничена, так как монолит сложно масштабировать по частям.
        
*   **Развёртывание:** Требует остановки всего приложения.
        

## 3.  Определение доменов и границ контекстов
*  **Управление отоплением (Heating Control):** Обработка запросов на включение и выключение отопления. Управляет состоянием устройства отопления в домах.
    
*  **Мониторинг температуры (Temperature Monitoring):** Получает и обрабатывает данные о температуре из установленных датчиков, хранит их и предоставляет доступ для пользователей.
        
*  **Управление устройствами (Device Management):** Домен для подключения и управления устройствами. В будущем он будет ответственен за поддержку и настройку различных устройств (например, освещение, камеры, ворота).
        
*  **Аутентификация и авторизация (Authentication & Authorization):** Обеспечивает безопасность, управляет доступом пользователей к системе, их правами и сессиями.
    
*  **Управление уведомлениями (Notification Management):** Домен для обработки и отправки уведомлений пользователям о статусе системы, например, уведомлений о текущем статусе температурного режима или о том, что датчик вышел из строя.
    

## 4.  Анализ проблем монолитного приложения

Монолитная архитектура приложения имеет несколько недостатков, особенно в контексте целей по расширению функциональности и масштабирования

* **Сложность масштабирования:** С монолитной структурой невозможно гибко масштабировать отдельные компоненты системы.
        
* **Ограниченная гибкость и расширяемость:** Сложность добавления новой функциональности (например, управление другими устройствами) и поддержки системы.
        
* **Проблемы с развёртыванием и обновлениями:** Развёртывание новой версии требует остановки всего приложения, что может приводить к простоям.
        
* **Низкая отказоустойчивость:** В случае отказа одной функции, например, мониторинга температуры, может нарушиться работа всей системы.
        
* **Зависимость от синхронного взаимодействия:** Ограничения, связанные с использованием синхронных операций.
    

Текущая монолитная архитектура представляет собой ограничение для реализации бизнес-целей компании, поскольку затрудняет внедрение новых функций и управление масштабированием.

## 5. Визуализация контекста системы (Context Diagram)

C4 - Уровень контекста (Context) - 1_Monolith_Context_Diagram.puml






# Задание 2. Проектирование микросервисной архитектуры

## 1. Декомпозиция приложения на микросервисы

Основываясь на выделенных доменах и бизнес-целях, микросервисы можно разделить следующим образом:

#### Основные микросервисы

1.  **Heating Control (Управление отоплением):**
    
*   Управляет включением и выключением отопления.
        
*   Поддерживает сценарии работы в зависимости от внешних условий и предпочтений пользователя.
        
2.  **Temperature Monitoring (Мониторинг температуры):**
    
*   Получает данные о температуре с датчиков и сохраняет их для дальнейшего использования.
        
*   Предоставляет данные в реальном времени для просмотра пользователем.
        
3.  **Device Management (Управление устройствами):**
    
*   Управляет подключением новых устройств, таких как освещение, ворота и т.д.
        
*   Поддерживает работу с устройствами партнёров по стандартным протоколам.
        
4.  **User Management (Управление пользователями):**
    
*   Обеспечивает регистрацию, аутентификацию и авторизацию пользователей.
        
*   Управляет правами и настройками пользователя для управления их устройствами.
        
5.  **Notification Service (Служба уведомлений):**
    
*   Отправляет уведомления пользователям (например, об изменении температуры, неисправностях и т.д.).
        
*   Поддерживает несколько каналов уведомлений, таких как e-mail, push-уведомления и SMS.
        
6.  **Scenario Management (Управление сценариями):**
    
*   Позволяет пользователям создавать и управлять сценариями автоматизации (например, включение света при открытии ворот или включение отопления при низкой температуре).
        
*   Обеспечивает возможность гибкой настройки сценариев.
        
7.  **Logging & Monitoring (Логирование и мониторинг):**
    
*   Сохраняет логи и метрики для аналитики и диагностики системы.
        
*   Поддерживает централизованное хранилище для логов всех микросервисов и аналитических данных.
        

#### Дополнительные компоненты архитектуры

1.  **API Gateway:** обеспечивает единый точку входа для всех клиентских запросов, управляет маршрутизацией к микросервисам, обеспечивает аутентификацию и авторизацию, и может выполнять базовую обработку запросов.
    
2.  **Message Broker (Kafka):** используется для асинхронного обмена сообщениями между микросервисами, что повышает гибкость и надёжность системы.
    

## 2. Взаимодействия между компонентами

#### Основные взаимодействия:

* **API Gateway** — единый вход для клиентских запросов, маршрутизирует их к микросервисам.
* **Kafka (Message Broker)** — асинхронная передача сообщений, например, данных о температуре.

##### Микросервисы:
* **Heating Control Service** — управление отоплением.
* **Temperature Monitoring Service** — мониторинг и хранение температурных данных.
* **Device Management Service** — управление подключёнными устройствами.
* **User Management Service** — регистрация и авторизация пользователей.
* **Notification Service** — отправка уведомлений пользователям.
* **Scenario Management Service** — управление пользовательскими сценариями.
* **Logging & Monitoring Service** — логирование и мониторинг системы.
            

## 3. Визуализация архитектуры:

*   C4 — Уровень контейнеров (Containers) - C4_2_TOBE_Container.puml
*   C4 — Уровень компонентов (Components) - C4_3_TOBE_Components.puml
        Пример диаграммы Components для сервиса Device Management Service 
*   C4 — Уровень кода (Code) - C4_4_TOBE_Code.puml
        Пример диаграммы Code для сценария добавления нового устройства.




# Задание 3. Разработка ER-диаграммы


## 1. Определение сущностей и их атрибутов

1.  **Пользователь (User):**
    
*   user\_id (PK) — уникальный идентификатор пользователя.
       
*   name — имя пользователя.
        
*   email — электронная почта.
        
*   password\_hash — хэш пароля для аутентификации.
        
*   phone\_number — телефонный номер пользователя.
        
2.  **Дом (House):**
    
*   house\_id (PK) — уникальный идентификатор дома.
        
*   user\_id (FK) — идентификатор владельца дома (внешний ключ к User).
        
*   address — адрес дома.
       
*   name — название дома (например, «Загородный дом»).
        
3.  **Устройство (Device):**
    
*   device\_id (PK) — уникальный идентификатор устройства.
        
*   device\_type\_id (FK) — тип устройства (внешний ключ к DeviceType).
        
*   house\_id (FK) — идентификатор дома, к которому привязано устройство.
        
*   serial\_number — серийный номер устройства.
        
*   status — текущее состояние устройства (например, включено/выключено).
        
4.  **Тип устройства (DeviceType):**
    
*   device\_type\_id (PK) — уникальный идентификатор типа устройства.
        
*   type\_name — название типа устройства (например, «Термостат», «Камера», «Датчик освещения»).
        
*   description — описание типа устройства.
        
5.  **Модуль (Module):**
    
*   module\_id (PK) — уникальный идентификатор модуля.
        
*   name — название модуля (например, «Отопление», «Охрана»).
        
*   description — описание модуля.
        
6.  **Телеметрия (TelemetryData):**
    
*   telemetry\_id (PK) — уникальный идентификатор записи телеметрии.
        
*   device\_id (FK) — идентификатор устройства, к которому относится запись.
        
*   timestamp — дата и время создания записи.
        
*   temperature — значение температуры (если устройство — термостат).
        
*   status — статус устройства в момент записи.
        
*   other\_data — дополнительные данные (в зависимости от устройства).


## 2. Определение связей между сущностями

*   **User-House**: Один пользователь может быть связан с несколькими домами, но каждый дом имеет только одного пользователя. (Связь «Один-ко-многим»)
    
*   **House-Device**: Один дом может содержать несколько устройств, каждое устройство привязано к одному дому. (Связь «Один-ко-многим»)
    
*   **Device-DeviceType**: Каждое устройство имеет один тип, а тип может быть общим для нескольких устройств. (Связь «Один-ко-многим»)
    
*   **Device-TelemetryData**: Одно устройство может генерировать множество записей телеметрии. (Связь «Один-ко-многим»)
    
*   **Module-Device**: Один модуль может включать несколько устройств, но устройство может принадлежать только одному модулю. (Связь «Один-ко-многим»)

## Описание связей:
*   **User (Пользователь)** связан с **House (Дом)** через связь «один-ко-многим» (один пользователь владеет несколькими домами).
*   **House** связан с **Device (Устройство)** через связь «один-ко-многим» (один дом содержит несколько устройств).
*   **Device** связан с **Module (Модуль)** через связь «один-ко-многим» (одно устройство может содержать несколько модулей).
*   **Device** связан с **TelemetryData (Телеметрия)** через связь «один-ко-многим» (одно устройство генерирует множество записей телеметрии).
*   **Device** связан с **DeviceType (Тип устройства)** через связь «многие-к-одному» (несколько устройств могут быть одного типа).


## 4. ER-диаграмма на PlantUML
!! Диаграмма открывается без ошибок в http://www.plantuml.com/ 

ER-диаграмма - C4_5_TOBE_ER.puml 



----------


# Часть 2. Проектирование API


## 1. Выбор API и назначение микросервисов

Для синхронных операций, таких как запрос и управление состоянием устройства, будем использовать REST API. Для асинхронных уведомлений, таких как новые данные телеметрии, используем AsyncAPI на базе Kafka.

Микросервисы:

* **Heating Control Service** — управление отоплением.
* **Temperature Monitoring Service** — мониторинг и хранение температурных данных.
* **Device Management Service** — управление подключёнными устройствами.
* **User Management Service** — регистрация и авторизация пользователей.
* **Notification Service** — отправка уведомлений пользователям.
* **Scenario Management Service** — управление пользовательскими сценариями.


## 2. Проектирование API для выбранных микросервисов


### 1. API Heating Control Service


#### 1. Включить отопление

**Метод**:  `POST`  

**Путь**:  `/heating/on`  

**Описание**: Включает отопление с заданной температурой.

#### Запрос:

-   **Тело запроса (JSON)**:

    ```bash

    `{

      "userId": "string",

      "temperature": "number"

    }` 
	```


#### Ответ:

-   **Код 200 (успех)**:

    ```bash

    `{

      "status": "Heating turned on"

    }` 

	```

----------

#### 2. Выключить отопление

**Метод**:  `POST`  

**Путь**:  `/heating/off`  

**Описание**: Выключает отопление для указанного пользователя.

#### Запрос:

-   **Тело запроса (JSON)**:

    ```bash

    `{

      "userId": "string"

    }` 

	```


#### Ответ:

-   **Код 200 (успех)**:

	```bash

    `{

      "status": "Heating turned off"

    }` 

	```
	
----------

#### 3. Получить статус отопления

**Метод**:  `GET`  

**Путь**:  `/heating/status`  

**Описание**: Возвращает текущий статус отопления и установленную температуру для указанного пользователя.

#### Запрос:

-   **Параметры запроса**:

    -   `userId`  (строка, обязательный): Идентификатор пользователя, передаётся через строку запроса.



#### Ответ:

-   **Код 200 (успех)**:

	```bash

    `{

      "status": "on",

      "temperature": 22.5

    }` 
	
	```

----------



### 2. API Temperature Monitoring Service

#### 2. Сообщить о текущей температуре

**Метод**:  `POST`  
**Путь**:  `/temperature/report`  
**Описание**: Регистрирует текущую температуру, переданную датчиком, с указанием времени замера.

#### Запрос:

-   **Тело запроса (JSON)**:
    
    ```bash
        
    `{
      "sensorId": "string",
      "temperature": "number",
      "timestamp": "string (date-time)"
    }` 
    ```

    
#### Ответ:

-   **Код 200 (успех)**:
    
    ```bash
        
    `{
      "status": "Temperature data recorded"
    }` 
    
	```
----------

#### 2. Получить текущую температуру

**Метод**:  `GET`  
**Путь**:  `/temperature/current`  
**Описание**: Возвращает последнюю зарегистрированную температуру для указанного датчика.

#### Запрос:

-   **Параметры строки запроса**:
    -   `sensorId`  (строка, обязательный): Идентификатор датчика.



#### Ответ:

-   **Код 200 (успех)**:
    
    ```bash
    
    `{
      "temperature": 23.5,
      "timestamp": "2024-11-15T12:00:00Z"
    }` 
    ```
----------

#### 3. Получить историю температурных данных

**Метод**:  `GET`  
**Путь**:  `/temperature/history`  
**Описание**: Возвращает массив температурных данных за указанный временной интервал.

#### Запрос:

-   **Параметры строки запроса**:
    -   `sensorId`  (строка, обязательный): Идентификатор датчика.
    -   `startDate`  (строка в формате  `date-time`, обязательный): Начальная дата и время интервала.
    -   `endDate`  (строка в формате  `date-time`, обязательный): Конечная дата и время интервала.


#### Ответ:

-   **Код 200 (успех)**:
    
    ```bash
        
    `{
      "data": [
        {
          "temperature": 22.1,
          "timestamp": "2024-11-14T08:00:00Z"
        },
        {
          "temperature": 23.5,
          "timestamp": "2024-11-14T12:00:00Z"
        }
      ]
    }` 
    
    ```

----------

### 3. API Device Management Service

#### 1. Зарегистрировать устройство

**Метод**:  `POST`  
**Путь**:  `/devices/register`  
**Описание**: Регистрирует новое устройство в системе.

#### Запрос:

-   **Тело запроса (JSON)**:
    
    ```bash

    `{
      "deviceId": "string",
      "name": "string",
      "type": "string"
    }` 
    
	```

#### Ответ:

-   **Код 200 (успех)**:
    
    ```bash
    
    `{
      "status": "Device registered"
    }` 
    
	```

----------

#### 2. Удалить устройство

**Метод**:  `DELETE`  
**Путь**:  `/devices/remove`  
**Описание**: Удаляет зарегистрированное устройство.

#### Запрос:

-   **Тело запроса (JSON)**:
    
    ```bash
    
    `{
      "deviceId": "string"
    }` 
    
	```	

#### Ответ:

-   **Код 200 (успех)**:
    
    ```bash
    
    `{
      "status": "Device removed"
    }` 
    
    ```

----------

#### 3. Получить список устройств

**Метод**:  `GET`  
**Путь**:  `/devices/list`  
**Описание**: Возвращает список всех зарегистрированных устройств.

#### Запрос:

Нет параметров.

#### Ответ:

-   **Код 200 (успех)**:
    
    ```bash
    
    `{
      "devices": [
        {
          "deviceId": "string",
          "name": "string",
          "type": "string"
        }
      ]
    }` 
    
    ```

----------

#### 4. Получить информацию об устройстве

**Метод**:  `GET`  
**Путь**:  `/devices/details`  
**Описание**: Возвращает информацию о конкретном устройстве.

#### Запрос:

-   **Параметры строки запроса**:
    -   `deviceId`  (строка, обязательный): Уникальный идентификатор устройства.



#### Ответ:

-   **Код 200 (успех)**:
    
    ```bash
    
    `{
      "deviceId": "string",
      "name": "string",
      "type": "string",
      "status": "string"
    }` 
    
    ```




### 4. API User Management Service

#### 1. Регистрация пользователя

**Метод**:  `POST`  
**Путь**:  `/users/register`  
**Описание**: Регистрирует нового пользователя в системе.

#### Запрос:

-   **Тело запроса (JSON)**:
    
    ```bash

    `{
      "userId": "string",
      "name": "string",
      "email": "string",
      "password": "string"
    }` 
    
    ```


#### Ответ:

-   **Код 200 (успех)**:
    
    ```bash
    
    `{
      "status": "User registered"
    }` 
    
    ```

----------

#### 2. Удалить пользователя

**Метод**:  `DELETE`  
**Путь**:  `/users/remove`  
**Описание**: Удаляет зарегистрированного пользователя из системы.

#### Запрос:

-   **Тело запроса (JSON)**:
    
    ```bash
    
    `{
      "userId": "string"
    }` 
    
    ```

#### Ответ:

-   **Код 200 (успех)**:
    
    ```bash
    
    `{
      "status": "User removed"
    }` 
    
    ```

----------

#### 3. Получить список пользователей

**Метод**:  `GET`  
**Путь**:  `/users/list`  
**Описание**: Возвращает список всех зарегистрированных пользователей.

#### Запрос:

Нет параметров.

#### Ответ:

-   **Код 200 (успех)**:
    
    ```bash
    
    `{
      "users": [
        {
          "userId": "string",
          "name": "string",
          "email": "string"
        }
      ]
    }` 
    
    ```

----------

#### 4. Получить информацию о пользователе

**Метод**:  `GET`  
**Путь**:  `/users/details`  
**Описание**: Возвращает информацию о конкретном пользователе.

#### Запрос:

-   **Параметры строки запроса**:
    -   `userId`  (строка, обязательный): Уникальный идентификатор пользователя.



#### Ответ:

-   **Код 200 (успех)**:
    
    ```bash
    
    `{
      "userId": "string",
      "name": "string",
      "email": "string",
      "status": "string"
    }` 
    ```




### 5. API Notification Service


#### 1. Отправить уведомление

**Метод**:  `POST`  
**Путь**:  `/notifications/send`  
**Описание**: Отправляет уведомление указанному пользователю.

#### Запрос:

-   **Тело запроса (JSON)**:
    
    ```bash
    
    `{
      "userId": "string",
      "message": "string",
      "type": "string"
    }` 
    
    ```

#### Ответ:

-   **Код 200 (успех)**:
    
    ```bash
    
    `{
      "status": "Notification sent"
    }` 
    
    ```

----------

#### 2. Получить статус уведомления

**Метод**:  `GET`  
**Путь**:  `/notifications/status`  
**Описание**: Возвращает статус отправленного уведомления.

#### Запрос:

-   **Параметры строки запроса**:
    -   `notificationId`  (строка, обязательный): Уникальный идентификатор уведомления.

#### Пример:

	```bash
	`GET /notifications/status?notificationId=abcd1234` 
	```

#### Ответ:

-   **Код 200 (успех)**:
    
    ```bash
    
    `{
      "notificationId": "abcd1234",
      "status": "delivered"
    }` 
    ```

----------

#### 3. Получить историю уведомлений

**Метод**:  `GET`  
**Путь**:  `/notifications/history`  
**Описание**: Возвращает список уведомлений, отправленных указанному пользователю.

#### Запрос:

-   **Параметры строки запроса**:
    -   `userId`  (строка, обязательный): Уникальный идентификатор пользователя.
    -   `startDate`  (строка, обязательный): Начальная дата в формате  `date-time`.
    -   `endDate`  (строка, обязательный): Конечная дата в формате  `date-time`.




#### Ответ:

-   **Код 200 (успех)**:
    
    ```bash
    
    `{
      "notifications": [
        {
          "notificationId": "abcd1234",
          "message": "Message text",
          "type": "email",
          "status": "delivered",
          "timestamp": "2024-11-10T14:00:00Z"
        },
        {
          "notificationId": "efgh5678",
          "message": "Message text",
          "type": "sms",
          "status": "delivered",
          "timestamp": "2024-11-12T09:00:00Z"
        }
      ]
    }` 
	```

### 6. Scenario Management Service



#### 1. Создать новый сценарий

**Метод**:  `POST`  
**Путь**:  `/scenarios/create`  
**Описание**: Создаёт новый сценарий автоматизации для указанного пользователя.

#### Запрос:

-   **Тело запроса (JSON)**:
    
    ```bash
    
    `{
      "userId": "string",
      "trigger": "string",
      "action": "string"
    }` 
    
    ```

#### Ответ:

-   **Код 200 (успех)**:
    
    ```bash
    
    `{
      "status": "Scenario created",
      "scenarioId": "string"
    }` 
    
    ```
----------

#### 2. Удалить существующий сценарий

**Метод**:  `DELETE`  
**Путь**:  `/scenarios/delete`  
**Описание**: Удаляет сценарий по его уникальному идентификатору.

#### Запрос:

-   **Параметры строки запроса**:
    -   `scenarioId`  (строка, обязательный): Уникальный идентификатор сценария, который нужно удалить.


#### Ответ:

-   **Код 200 (успех)**:
    
    ```bash
    
    `{
      "status": "Scenario deleted"
    }` 
    
    ```

----------

### 3. Получить список сценариев пользователя

**Метод**:  `GET`  
**Путь**:  `/scenarios/list`  
**Описание**: Возвращает список всех сценариев, связанных с указанным пользователем.

#### Запрос:

-   **Параметры строки запроса**:
    -   `userId`  (строка, обязательный): Уникальный идентификатор пользователя.



#### Ответ:

-   **Код 200 (успех)**:
    
    ```bash
    
    `{
      "scenarios": [
        {
          "scenarioId": "abcd1234",
          "trigger": "триггер",
          "action": "действие 1"
        },
        {
          "scenarioId": "efgh5678",
          "trigger": "триггер",
          "action": "включить устройство"
        }
      ]
    }` 
    
    ```

## 4. Документирование API с помощью Swagger и AsyncAPI


API описаны в файлах с соответставующими микросервисам именами:
* **API_Heating Control Service.yaml**
* **API_Temperature Monitoring Service.yaml**
* **API_Device Management Service.yaml**
* **API_User Management Service.yaml**
* **API_Notification Service.yaml**	
* **API_Scenario Management Service.yaml**	
